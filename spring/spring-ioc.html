<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta name="google-site-verification" content="DwDg4EuywHWNZUkTC7sG0WGv_UQekM4uRtOoaGuDJHc">
<meta name="baidu-site-verification" content="hkLiBHH93D">
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Spring源码分析之IOC">




  <meta name="keywords" content="Spring,">




  <link rel="alternate" href="/default" title="JinJin's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="https://jinzzzzz.github.io/spring/spring-ioc.html">


<meta name="description" content="目录：   Spring的IOC与DI Spring 核心类 BeanFactory BeanDefinition BeanDefinitionReader   基于 Xml 的 IOC 容器的初始化 1、寻找入口 2、获得配置路径 3、开始启动 4、创建容器 5、载入配置路径 6、分配路径处理策略 7、解析配置文件路径 8、开始读取配置内容 9、准备文档对象 10、分配解析策略 11、将配置载入">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码分析之IOC">
<meta property="og:url" content="https://jinzzzzz.github.io/spring/spring-ioc.html">
<meta property="og:site_name" content="JinJin&#39;s Blog">
<meta property="og:description" content="目录：   Spring的IOC与DI Spring 核心类 BeanFactory BeanDefinition BeanDefinitionReader   基于 Xml 的 IOC 容器的初始化 1、寻找入口 2、获得配置路径 3、开始启动 4、创建容器 5、载入配置路径 6、分配路径处理策略 7、解析配置文件路径 8、开始读取配置内容 9、准备文档对象 10、分配解析策略 11、将配置载入">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beanfactory.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beandefinition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beandefinitionreader.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/applicationcontext.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/resoureloader.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/spring-ioc.jpg">
<meta property="og:updated_time" content="2019-04-03T08:28:28.156Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码分析之IOC">
<meta name="twitter:description" content="目录：   Spring的IOC与DI Spring 核心类 BeanFactory BeanDefinition BeanDefinitionReader   基于 Xml 的 IOC 容器的初始化 1、寻找入口 2、获得配置路径 3、开始启动 4、创建容器 5、载入配置路径 6、分配路径处理策略 7、解析配置文件路径 8、开始读取配置内容 9、准备文档对象 10、分配解析策略 11、将配置载入">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beanfactory.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">






<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  





<!--百度统计-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b733e1eaeacbf8f87d3be047f28c3973";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <title> Spring源码分析之IOC - JinJin's Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">JinJin's Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Spring源码分析之IOC
        
      </h1>

      <time class="post-time">
          2019-04-03
      </time>
    </header>



    
            <div class="post-content">
            <p>目录：</p>
<!-- toc -->
<ul>
<li><a href="#spring的ioc与di">Spring的IOC与DI</a></li>
<li><a href="#spring-核心类">Spring 核心类</a><ul>
<li><a href="#beanfactory">BeanFactory</a></li>
<li><a href="#beandefinition">BeanDefinition</a></li>
<li><a href="#beandefinitionreader">BeanDefinitionReader</a></li>
</ul>
</li>
<li><a href="#基于-xml-的-ioc-容器的初始化">基于 Xml 的 IOC 容器的初始化</a><ul>
<li><a href="#1-寻找入口">1、寻找入口</a></li>
<li><a href="#2-获得配置路径">2、获得配置路径</a></li>
<li><a href="#3-开始启动">3、开始启动</a></li>
<li><a href="#4-创建容器">4、创建容器</a></li>
<li><a href="#5-载入配置路径">5、载入配置路径</a></li>
<li><a href="#6-分配路径处理策略">6、分配路径处理策略</a></li>
<li><a href="#7-解析配置文件路径">7、解析配置文件路径</a></li>
<li><a href="#8-开始读取配置内容">8、开始读取配置内容</a></li>
<li><a href="#9-准备文档对象">9、准备文档对象</a></li>
<li><a href="#10-分配解析策略">10、分配解析策略</a></li>
<li><a href="#11-将配置载入内存">11、将配置载入内存</a></li>
<li><a href="#12-载入bean元素">12、载入bean元素</a></li>
<li><a href="#13-载入property元素">13、载入property元素</a></li>
<li><a href="#14-载入property的子元素">14、载入property的子元素</a></li>
<li><a href="#15-载入list的子元素">15、载入list的子元素</a></li>
<li><a href="#16-分配注册策略">16、分配注册策略</a></li>
<li><a href="#17-向容器注册">17、向容器注册</a></li>
</ul>
</li>
<li><a href="#基于-annotation-的初始化">基于 Annotation 的初始化</a><ul>
<li><a href="#定位-bean-扫描路径">定位 Bean 扫描路径</a></li>
<li><a href="#读取-annotation-元数据">读取 Annotation 元数据</a><ul>
<li><a href="#1annotationconfigapplicationcontext-调用注解-bean-定义读取器">1)AnnotationConfigApplicationContext 调用注解 Bean 定义读取器</a></li>
<li><a href="#2annotationscopemetadataresolver-解析作用域元数据">2)AnnotationScopeMetadataResolver 解析作用域元数据</a></li>
<li><a href="#3annotationconfigutils-处理注解-bean-定义类中的通用注解">3)AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解</a></li>
<li><a href="#4annotationconfigutils-根据注解-bean-定义类中配置的作用域为其应用相应的代理策略">4)AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略</a></li>
<li><a href="#5beandefinitionreaderutils-向容器注册-bean">5)BeanDefinitionReaderUtils 向容器注册 Bean</a></li>
</ul>
</li>
<li><a href="#解析为beandefinition">解析为BeanDefinition</a><ul>
<li><a href="#1classpathbeandefinitionscanner-扫描给定的包及其子包">1)ClassPathBeanDefinitionScanner 扫描给定的包及其子包</a></li>
<li><a href="#2classpathscanningcandidatecomponentprovider-扫描给定包及其子包的类">2)ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ioc-容器初始化小结">IOC 容器初始化小结</a></li>
</ul>
<!-- tocstop -->
<h1><span id="spring的ioc与di">Spring的IOC与DI</span></h1><p>IOC(Inversion of Control)是控制反转，所谓控制反转，就是我们原来代码中自己创建的对象交由容器创建，由我们自己控制对象的创建和销毁转变为第三方，也就是spring的ioc容器去控制这个对象的创建；spring会扫描需要的路径下面的bean都注册到ioc容器中；</p>
<p>那么我们的对象不会自己去IOC容器中查找需要的依赖的类，而是IOC容器在初始化的时候将对象中需要依赖的类进行注入，也就是依赖注入（DI），那就需要一种描述让它知道对象和创建的对象之间的对应关系，也就是配置文件或者是注解；</p>
<h1><span id="spring-核心类">Spring 核心类</span></h1><h2><span id="beanfactory">BeanFactory</span></h2><p>Spring Bean 的创建为工厂模式，这一系列的 Bean 工厂就是IOC容器，它为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用</p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beanfactory.png" alt></p>
<p>BeanFactory 作为最顶层的一个接口类，定义了 IOC 容器的基本功能。BeanFactory 的子类分别定义了不同的功能，ListableBeanFactory表示这些 Bean 是可列表化的，HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的， AutowireCapableBeanFactory定义 Bean 的自动装配规则。DefaultListableBeanFactory是默认的实现类，它实现了所有的接口。</p>
<p>BeanFactory接口源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line">	<span class="comment">//根据 bean 的名字，获取在 IOC 容器中得到 bean 实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="comment">//根据 bean 的名字和 Class 类型来得到 bean 实例，增加了类型安全验证机制。</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="comment">//提供对 bean 的检索，看看是否在 IOC 容器有这个名字的 bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="comment">//根据 bean 名字得到 bean 实例，并同时判断这个 bean 是不是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">//得到 bean 实例的 Class 类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">	<span class="comment">//得到 bean 的别名</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactory 里只对 IOC 容器的基本行为作了定义，并不关心 Bean 是如何定义怎样加载的。</p>
<p>Spring 提供了许多 IOC 容器的实现 ，比如 ApplicationContext ，它是 Spring 提供的一个高级的 IOC 容器，它除了能够提供 IOC 容器的基本功能外，还为用户提供了一些附加服务：</p>
<ol>
<li>支持不同的信息源。它扩展了MessageResource 接口，这些信息源的功能可以支持国际化的实现。</li>
<li>访问资源。这一特性体验在Resource 与ResourceLoader 上，这样一来，就可以从不同的地方得到Bean 定义资源。如URL和文件 。</li>
<li>支持应用事件。继承了接口ApplicationEventPublisher，从而在上下文中引入了事件机制。这些事件和Bean 的生命周期的结合为Bean 的管理提供了便利。</li>
</ol>
<h2><span id="beandefinition">BeanDefinition</span></h2><p>Spring IOC 将定义的 Bean 定义资源文件转换为 Spring IOC 所识别的数据结构，也就是BeanDefinition，它是<br>Bean定义资源文件中配置的POJO对象在 Spring IOC 容器的映射 。</p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beandefinition.png" alt></p>
<h2><span id="beandefinitionreader">BeanDefinitionReader</span></h2><p>Bean 的解析过程功能很细，这里需要被扩展的地方很多，有足够的灵活性应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成。</p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/beandefinitionreader.png" alt></p>
<h1><span id="基于-xml-的-ioc-容器的初始化">基于 Xml 的 IOC 容器的初始化</span></h1><p>IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、配置文件的加载和加载的信息注册到容器三个基本的过程。以ApplicationContext 为例。Web 项目中使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext等。</p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/applicationcontext.png" alt></p>
<h2><span id="1-寻找入口">1、寻找入口</span></h2><p>使用ClassPathXmlApplicationContext，通过 main()方法启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>看其构造方法的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际调用构造函数为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	<span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">		<span class="keyword">this</span>.refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用 refresh()方法。</p>
<h2><span id="2-获得配置路径">2、获得配置路径</span></h2><p>创建ClassPathXmlApplicationContext容器时，构造方法首先调用父类容器的构造方法为容器设置好 Bean 资源加载器。然后再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置 Bean 配置信息的定位路径。</p>
<p>追踪ClassPathXmlApplicationContext的继承体系，发现其父类中AbstractApplicationContext中初始化 IOC 容器所做的主要源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态初始化块</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		ContextClosedEvent.class.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		setParent(parent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取一个 Spring Source 的加载器用于读入 Spring Bean 配置信息</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器</span></span><br><span class="line">		<span class="comment">//Spring 资源加载器，其 getResource(String location)方法用于载入资源</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext 的默认构造方法中调用 PathMatchingResourcePatternResolver 的构造方法创建 Spring 资源加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null"</span>);</span><br><span class="line">	<span class="comment">//设置 Spring 的资源加载器</span></span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来 ClassPathXmlApplicationContext 通过调用其父类AbstractRefreshableConfigApplicationContext的 setConfigLocations()方法方法进行对Bean配置信息的定位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String location)</span> </span>&#123; </span><br><span class="line">	setConfigLocations(StringUtils.tokenizeToStringArray(location, 	CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">			<span class="comment">//resolvePath 方法为将字符串解析为路径</span></span><br><span class="line">			<span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法的源码表示既可以使用一个字符串来配置多个 Spring Bean 配置信息，也可以使用字符串数组。</p>
<p>即下面两种方式都是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"a.xml,b.xml"</span>);</span><br><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="keyword">new</span> String[]&#123;<span class="string">"a.xml"</span>,<span class="string">"b.xml"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>SpringIOC 容器在初始化时将配置的 Bean 配置信息定位为 Spring 封装的 Resource。</p>
<h2><span id="3-开始启动">3、开始启动</span></h2><p>ClassPathXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh()函数启动整个 IOC 容器对 Bean 定义的载入过程，现在来详细看看 refresh()中的逻辑处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">		prepareRefresh(); </span><br><span class="line">		<span class="comment">//2、Bean 定义资源文件的载入子类类的 refreshBeanFactory()方法启动</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); </span><br><span class="line">		<span class="comment">//3、为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			<span class="comment">//4、为容器的某些子类指定特殊的 BeanPost 事件处理器</span></span><br><span class="line">			postProcessBeanFactory(beanFactory); </span><br><span class="line">			<span class="comment">//5、调用所有注册的 BeanFactoryPostProcessor 的 Bean</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory); </span><br><span class="line">			<span class="comment">//6、为 BeanFactory 注册 BeanPost 事件处理器.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">			<span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">			<span class="comment">//9、调用子类的某些特殊 Bean 初始化方法</span></span><br><span class="line">			onRefresh(); 		</span><br><span class="line">			<span class="comment">//10、为事件传播器注册事件监听器</span></span><br><span class="line">   			registerListeners(); </span><br><span class="line">			<span class="comment">//11、初始化所有剩余的单例 Bean</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			<span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//13、销毁已创建的 Bean</span></span><br><span class="line">			destroyBeans(); </span><br><span class="line">			<span class="comment">//14、取消 refresh 操作，重置容器的同步标识.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123; </span><br><span class="line">			<span class="comment">//15、重设公共缓存</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh()方法的主要作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。它类似于对 IOC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 配置资源进行载入。</p>
<h2><span id="4-创建容器">4、创建容器</span></h2><p>obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入 Bean 配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refreshBeanFactory()是抽象方法，实际调用的是其子类 AbstractRefreshableApplicationContext 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//如果已经有容器，销毁容器中的 bean，关闭容器</span></span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建 IOC 容器</span></span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		<span class="comment">//对 IOC 容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		<span class="comment">//调用载入 Bean 定义的方法</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(),ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，</p>
<p>接着创建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory)装载 bean 定义。</p>
<h2><span id="5-载入配置路径">5、载入配置路径</span></h2><p>loadBeanDefinitions 同样是抽象方法，真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractXmlApplicationContext</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Bean 读取器，并通过回调设置到容器中去，容器使用该读取器读取 Bean 配置资源</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="comment">//为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//为 Bean 读取器设置 SAX xml 解析器</span></span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        <span class="comment">//Bean 读取器真正实现加载的方法</span></span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">        reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Xml Bean 读取器加载 Bean 配置资源</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取 Bean 配置资源的定位</span></span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源</span></span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子类中获取的 Bean 配置资源定位为空，则获取 ClassPathXmlApplicationContext构造方法中 setConfigLocations 方法设置的资源</span></span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源</span></span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Resource[] getConfigResources() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。<br>由于使用 ClassPathXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。</p>
<h2><span id="6-分配路径处理策略">6、分配路径处理策略</span></h2><p>AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用loadBeanDefinitions(String, Set&lt;Resource&gt;)方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span>	BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		<span class="comment">//获取在 IOC 容器初始化过程中设置的资源加载器</span></span><br><span class="line">		ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">		<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//加载多个指定位置的 Bean 配置信息</span></span><br><span class="line">				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">				<span class="comment">//委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span></span><br><span class="line">				<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">				<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">						actualResources.add(resource);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">return</span> loadCount;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//加载单个指定位置的 Bean 配置信息</span></span><br><span class="line">			Resource resource = resourceLoader.getResource(location);</span><br><span class="line">            <span class="comment">//委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span></span><br><span class="line">   			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                actualResources.add(resource)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用loadBeanDefinitions(String方法)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadBeanDefinitions()方法首先调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在<br>loadBeanDefinitions()方法中调用了 AbstractApplicationContext 的 getResources()方法，getResources()方法其实定义在 ResourcePatternResolver 中，此时需要看下ResourcePatternResolver 的全类图</p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/resoureloader.png" alt></p>
<p>从图中可以看到 ResourceLoader 与 ApplicationContext 的继承关系，实际调用的是DefaultResourceLoader 中 的 getSource() 方法定位Resource ， 因 为ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了ClassPathXmlApplicationContext 中。</p>
<h2><span id="7-解析配置文件路径">7、解析配置文件路径</span></h2><p>ClassPathXmlApplicationContext类的父类DefaultResourceLoader 的 getResource()方法源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">	<span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">		Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是类路径的方式，那需要使用 ClassPathResource 来得到 bean 文件的资源对象</span></span><br><span class="line">	<span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是 URL 方式，使用 UrlResource 作为 bean 文件的资源对象</span></span><br><span class="line">		URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">		<span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">		<span class="comment">//如果既不是 classpath 标识，又不是 URL 标识的 Resource 定位，则调用容器本身的 getResourceByPath 方法获取 Resource</span></span><br><span class="line">		<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultResourceLoader 提供了 getResourceByPath()方法的实现，就是为了处理既不是 classpath标识，又不是 URL 标识的 Resource 定位这种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ClassPathResource 中完成了对整个路径的解析。这样，就可以从类路径上对 IOC 配置文件进行加载，在 Spring 中看到它提供的各种资源抽象，比如ClassPathResource、URLResource、FileSystemResource 等来供我们使用。上面看到的是定位Resource 的一个过程，而这只是加载过程的一部分。例如 FileSystemXmlApplication 容器就重写了getResourceByPath()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里使用文件系统资源对象来定义 bean 文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过子类的覆盖，完成了将类路径变为文件路径的转换。</p>
<h2><span id="8-开始读取配置内容">8、开始读取配置内容</span></h2><p>继续 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文件的资源定义以后的载入过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//将读入的 XML 资源进行特殊编码处理</span></span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将资源文件转为 InputStream 的 IO 流</span></span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//从 InputStream 中得到 XML 的解析源</span></span><br><span class="line">				InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">				<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//这里是具体的读取过程</span></span><br><span class="line">				<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//关闭从 Resource 中得到的 IO 流</span></span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从特定 XML 文件中实际载入 Bean 配置资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将 XML 文件转换为 DOM 对象，解析过程由 documentLoader 实现</span></span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">//这里是启动对 Bean 定义解析的详细过程，该解析过程会用到 Spring 的 Bean 配置规则</span></span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载入 Bean 配置信息的最后是将 Bean 配置信息转换为 Document 对象，该过程由documentLoader()方法实现。</p>
<h2><span id="9-准备文档对象">9、准备文档对象</span></h2><p>DocumentLoader 将 Bean 配置资源转换成 Document 对象的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//创建文件解析器工厂</span></span><br><span class="line">	DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建文档解析器</span></span><br><span class="line">	DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">	<span class="comment">//解析 Spring 的 Bean 配置资源</span></span><br><span class="line">	<span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span>	<span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">    <span class="comment">//创建文档解析工厂</span></span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">	factory.setNamespaceAware(namespaceAware);</span><br><span class="line">	<span class="comment">//设置解析 XML 的校验</span></span><br><span class="line">	<span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">		factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">			factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">				ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(</span><br><span class="line"><span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory +</span><br><span class="line"><span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> +</span><br><span class="line"><span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);</span><br><span class="line">				pcex.initCause(ex);</span><br><span class="line">				<span class="keyword">throw</span> pcex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 Spring IOC 容器根据定位的 Bean 配置信息，将其加载读入并转换成为 Document 对象过程完成。接下来要继续分析 Spring IOC 容器将载入的 Bean 配置信息转换为 Document 对象之后，是如何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中的。</p>
<h2><span id="10-分配解析策略">10、分配解析策略</span></h2><p>XmlBeanDefinitionReader 类中的 doLoadBeanDefinition()方法是从特定 XML 文件中实际载入Bean 配置资源的方法，该方法在载入 Bean 配置资源之后将其转换为 Document 对象，接下来调用registerBeanDefinitions() 启 动 Spring IOC 容 器 对 Bean 定 义 的 解 析 过 程 ，registerBeanDefinitions()方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照 Spring 的 Bean 语义要求将 Bean 配置资源解析并转换为容器内部数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//得到 BeanDefinitionDocumentReader 来对 xml 格式的 BeanDefinition 解析</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">//获得容器中注册的 Bean 数量</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">//具体的解析实现过程由实现类 DefaultBeanDefinitionDocumentReader 完成</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">//统计解析的 Bean 数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bean 配置资源的载入解析首先通过调用 XML 解析器将 Bean 配置信息转换得到 Document 对象，然后在完成通用的 XML 解析之后，按照 Spring Bean 的定义规则对 Document 对象进行解析，其解析的过程在接口</p>
<p>BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader类中实现。</p>
<h2><span id="11-将配置载入内存">11、将配置载入内存</span></h2><p>DefaultBeanDefinitionDocumentReader 的registerBeanDefinitions()方法对 Document 对象进行解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据 Spring DTD 对 Bean 的定义规则解析 Bean 定义 Document 对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获得 XML 描述符</span></span><br><span class="line">	<span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">	<span class="comment">//获得 Document 的根元素</span></span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在解析 Bean 定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	<span class="comment">//从 Document 的根元素开始进行 Bean 定义的 Document 对象</span></span><br><span class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">	<span class="comment">//在解析 Bean 定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">	postProcessXml(root);    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 Bean 配置资源 Document 对象的普通元素</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">// BeanDefinitionHolder 是对 BeanDefinition 的封装，即 Bean 定义的封装类</span></span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//向 Spring IOC 容器注册解析得到的 Bean 定义，这是 Bean 定义向 IOC 容器注册的入口</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, 				getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//在完成向 Spring IOC 容器注册解析得到的 Bean 定义之后，发送注册事件</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(</span><br><span class="line">            <span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//具体代码可自行查看</span></span><br></pre></td></tr></table></figure>
<p>在使用 Spring 时，Spring 配置文件中可以使用<import>元素来导入 IOC 容器所需要的其他资源，Spring IOC 容器在解析时会首先将指定导入的资源加载进容器中。使用<ailas>别名时，Spring IOC 容器首先将别名元素所<br>定义的别名注册到容器中。<br>对于既不是<import>元素，又不是<alias>元素的元素，即 Spring 配置文件中普通的<bean>元素的解析由 </bean></alias></import></ailas></import></p>
<p>BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement()方法来实现。</p>
<h2><span id="12-载入bean元素">12、载入bean元素</span></h2><p>Bean 配置信息中的<import>和<alias>元素解析在 DefaultBeanDefinitionDocumentReader 中已经完成，对 Bean 配置信息中使用最多的<bean>元素交由 BeanDefinitionParserDelegate 来解析</bean></alias></import></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析&lt;Bean&gt;元素的入口</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 Bean 配置信息中的&lt;Bean&gt;元素，主要处理&lt;Bean&gt;元素的 id，name 和别名属性</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//详细对&lt;Bean&gt;元素中配置的 Bean 定义进行解析</span></span><br><span class="line">	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName,</span><br><span class="line">containingBean);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法中主要处理除这id、name和别名以外的其他属性数据</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析<bean>元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类BeanDefinition，将<bean>元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。</bean></bean></p>
<p>在使用 Spring 的<bean>元素时，配置最多的还是<property>属性，因此下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。</property></bean></p>
<h2><span id="13-载入property元素">13、载入property元素</span></h2><p>BeanDefinitionParserDelegate 在解析<bean>调用 parsePropertyElements()方法解析元素中的<property>属性子元素。</property></bean></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;Bean&gt;元素中所有的子元素</span></span><br><span class="line">	NodeList nl = beanEle.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node = nl.item(i);</span><br><span class="line">		<span class="comment">//如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析</span></span><br><span class="line">		<span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">			parsePropertyElement((Element) node, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析&lt;property&gt;元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//解析获取 property 的值</span></span><br><span class="line">	Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">	<span class="comment">//根据 property 的名字和值创建 property 实例</span></span><br><span class="line">	PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">	<span class="comment">//解析&lt;property&gt;元素中的属性</span></span><br><span class="line">	parseMetaElements(ele, pv);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析获取 property 值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, @Nullable String propertyName)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果属性是 ref，创建一个 ref 的数据对象 RuntimeBeanReference</span></span><br><span class="line">	<span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">		String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//一个指向运行时所依赖对象的引用</span></span><br><span class="line">		RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">		<span class="comment">//设置这个 ref 的数据对象是被当前的 property 对象所引用</span></span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果属性是 value，创建一个 value 的数据对象 TypedStringValue</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">		<span class="comment">//一个持有 String 类型值的对象</span></span><br><span class="line">		TypedStringValue valueHolder = <span class="keyword">new</span> 		TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">		<span class="comment">//设置这个 value 数据对象是被当前的 property 对象所引用</span></span><br><span class="line">		valueHolder.setSource(extractSource(ele));</span><br><span class="line">	<span class="keyword">return</span> valueHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果当前&lt;property&gt;元素还有子元素</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//解析&lt;property&gt;的子元素</span></span><br><span class="line">		<span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//propery 属性中既不是 ref，也不是 value 属性，解析出错返回 null</span></span><br><span class="line">		error(elementName + <span class="string">" must specify a ref or value"</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring 配置文件中，<bean>元素中<property>元素的相关配置处理：<br>1、ref 被封装为指向依赖对象一个引用。<br>2、value 配置都会封装成一个字符串类型的对象。<br>3、ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来。<br>在方法的最后对于<property>元素的子元素通过 parsePropertySubElement()方法解析，继续分析该方法的源码，了解其解析过程</property></property></bean></p>
<h2><span id="14-载入property的子元素">14、载入property的子元素</span></h2><p>在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement()方法对<property>中的子元素解析。</property></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析&lt;property&gt;元素中 ref,value 或者集合等子元素</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果&lt;property&gt;没有使用 Spring 默认的命名空间，则使用用户自定义的规则解析内嵌元素</span></span><br><span class="line">	<span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是 bean，则使用解析&lt;Bean&gt;元素的方法解析</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123; </span><br><span class="line">		BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">		<span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">			nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> nestedBd;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是 ref，ref 中只能有以下 3 个属性：bean、local、parent</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">//可以不再同一个 Spring 配置文件中，具体请参考 Spring 对 ref 的配置规则</span></span><br><span class="line">		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">			<span class="comment">//获取&lt;property&gt;元素中 parent 属性值，引用父级容器中的 Bean</span></span><br><span class="line">			refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">			toParent = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">				error(<span class="string">"'bean' or 'parent' is required for &lt;ref&gt; element"</span>, ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(<span class="string">"&lt;ref&gt; element contains empty target attribute"</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//创建 ref 类型数据，指向被引用的对象</span></span><br><span class="line">		RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">		<span class="comment">//设置引用类型值是被当前子元素所引用</span></span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;idref&gt;，使用解析 ref 元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;value&gt;，使用解析 value 元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是 null，为&lt;property&gt;设置一个封装 null 值的字符串数据</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">		TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">		nullHolder.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> nullHolder;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;array&gt;，使用解析 array 集合子元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;list&gt;，使用解析 list 集合子元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;set&gt;，使用解析 set 集合子元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;map&gt;，使用解析 map 集合子元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果子元素是&lt;props&gt;，使用解析 props 集合子元素的方法解析</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//既不是 ref，又不是 value，也不是集合，则子元素配置错误，返回 null</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring 配置文件中，对<property>元素中配置的 array、list、set、map、prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。</list></property></p>
<h2><span id="15-载入list的子元素">15、载入list的子元素</span></h2><p>BeanDefinitionParserDelegate 类中的 parseListElement()方法就是具体实现解析<property>元素中的<list>集合子元素</list></property></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析&lt;list&gt;集合子元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">parseListElement</span><span class="params">(Element collectionEle, @Nullable BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;list&gt;元素中的 value-type 属性，即获取集合元素的数据类型</span></span><br><span class="line">	String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span><br><span class="line">	<span class="comment">//获取&lt;list&gt;集合元素中的所有子节点</span></span><br><span class="line">	NodeList nl = collectionEle.getChildNodes();</span><br><span class="line">	<span class="comment">//Spring 中将 List 封装为 ManagedList</span></span><br><span class="line">	ManagedList&lt;Object&gt; target = <span class="keyword">new</span> ManagedList&lt;&gt;(nl.getLength())</span><br><span class="line">    target.setSource(extractSource(collectionEle));</span><br><span class="line">	<span class="comment">//设置集合目标数据类型</span></span><br><span class="line">	target.setElementTypeName(defaultElementType);</span><br><span class="line">	target.setMergeEnabled(parseMergeAttribute(collectionEle));</span><br><span class="line">	<span class="comment">//具体的&lt;list&gt;元素解析</span></span><br><span class="line">	parseCollectionElements(nl, target, bd, defaultElementType);</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseCollectionElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">NodeList elementNodes, Collection&lt;Object&gt; target, @Nullable BeanDefinition bd, String defaultElementType)</span></span>&#123;</span><br><span class="line">	<span class="comment">//遍历集合所有节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementNodes.getLength(); i++) &#123;</span><br><span class="line">		Node node = elementNodes.item(i);</span><br><span class="line">		<span class="comment">//节点不是 description 节点</span></span><br><span class="line">		<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">//将解析的元素加入集合中，递归调用下一个子元素</span></span><br><span class="line">			target.add(parsePropertySubElement((Element) node, bd, defaultElementType));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过对 Spring Bean 配置信息转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将 XML形式定义的 Bean 配置信息转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是 Bean 配置信息中配置的 POJO 对象在 Spring IOC 容器中的映射，可以通过 AbstractBeanDefinition 为入口，看到了 IOC 容器进行索引、查询和操作。</p>
<p>通过 Spring IOC 容器对 Bean 配置资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中 BeanDefinition 存储的只是一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IOC 容器的初始化过程。</p>
<h2><span id="16-分配注册策略">16、分配注册策略</span></h2><p>继续跟踪程序的执行顺序，接下来分析 DefaultBeanDefinitionDocumentReader 对Bean 定义转换的Document 对象解析的流程中，在其 parseDefaultElement() 方 法中 完成对Document 对象解析后得到封装BeanDefinition 的 BeanDefinitionHold对象，然后调用BeanDefinitionReaderUtils 的 registerBeanDefinition()方法向IOC容器 注册解析的Bean 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将解析的 BeanDefinitionHold 注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//获取解析的 BeanDefinition 的名称</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	<span class="comment">//向 IOC 容器注册 BeanDefinition</span></span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">	<span class="comment">//如果解析的 BeanDefinition 有别名，向容器为其注册别名</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanDefinitionReaderUtils 向容器注册解析的 BeanDefinition,完成注册功能的是DefaultListableBeanFactory</p>
<h2><span id="17-向容器注册">17、向容器注册</span></h2><p>DefaultListableBeanFactory中使用一个HashMap的集合对象存放IOC容器中注册解析的BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储注册信息的 BeanDefinition</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向 IOC 容器注册解析的 BeanDefiniton</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">		<span class="comment">//注册的过程中需要线程同步，以保证数据的一致性</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">			updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">			updatedDefinitions.add(beanName);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">				Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                pdatedSingletons.remove(beanName);</span><br><span class="line">				<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">		<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Bean 配置信息中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正完成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护。这些的注册的 Bean 定义信息是 IOC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
<h1><span id="基于-annotation-的初始化">基于 Annotation 的初始化</span></h1><p>注解(Annotation)是 JDK1.5 中引入的一个新特性，用于简化 Bean 的配置，可以取代 XML 配置文件。注解可以大大简化配置，提高开发速度。随着 Spring Boot 的兴起，基于注解的开发甚至实现了零配置。Spring IOC 容器对于类级别的注解和类内部的注解分以下两种处理策略：<br>1)、类级别的注解：如@Component、@Repository、@Controller、@Service 以及 JavaEE6 的@ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规则扫描读取注解 Bean 定义类，并将其注册到 Spring IOC 容器中。<br>2)、类内部的注解：如@Autowire、@Value、@Resource 以及 EJB 和 WebService 相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过 Bean 后置注解处理器解析Bean 内部的注解。下面将根据这两种处理策略，分别分析 Spring 处理注解相关的源码。</p>
<h2><span id="定位-bean-扫描路径">定位 Bean 扫描路径</span></h2><p>AnnotationConfigApplicationContext 和AnnotationConfigWebApplicationContex这两个类是专门处理Spring 注解配置的容器，依赖于注解作为容器配置信息来源的 IOC 容器，AnnotationConfigWebApplicationContext 是<br>AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。</p>
<p>以 AnnotationConfigApplicationContext 为例看看它的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">//保存一个读取注解的 Bean 定义读取器，并将其设置到容器中</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">	<span class="comment">//保存一个扫描指定类路径中注解 Bean 定义的扫描器，并将其设置到容器中</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line">	<span class="comment">//默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其 register()</span></span><br><span class="line">	<span class="comment">//方法注册配置类，并调用 refresh()方法刷新容器，触发容器对注解 Bean 的载入、解析和注册过程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(beanFactory);</span><br><span class="line">		<span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的 Bean 自动注册到容器中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		register(annotatedClasses);</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的 Spring Bean，将其注册到容器中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		scan(basePackages);</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setEnvironment(environment);</span><br><span class="line">		<span class="keyword">this</span>.reader.setEnvironment(environment);</span><br><span class="line">		<span class="keyword">this</span>.scanner.setEnvironment(environment);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置 Bean 名称产生器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanNameGenerator</span><span class="params">(BeanNameGenerator beanNameGenerator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">		<span class="keyword">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">		getBeanFactory().registerSingleton(</span><br><span class="line">AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为容器的注解 Bean 读取器和注解 Bean 扫描器设置作用范围元信息解析器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScopeMetadataResolver</span><span class="params">(ScopeMetadataResolver scopeMetadataResolver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">		<span class="keyword">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为容器注册一个要被处理的注解 Bean，新注册的 Bean，必须手动调用容器的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">		<span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">		<span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码分析，可以看啊到 Spring 对注解的处理分为两种方式：<br>1)、直接将注解 Bean 注册到容器中<br>    可以在初始化容器时注册；也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容器，使得容器对注册的注解 Bean 进行处理。<br>2)、通过扫描指定的包及其子包下的所有类<br>    在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。<br>接下来，将会对两种处理方式详细分析其实现过程。</p>
<h2><span id="读取-annotation-元数据">读取 Annotation 元数据</span></h2><p>当创建注解处理容器时，如果传入的初始参数是具体的注解 Bean 定义类时，注解容器读取并注册。</p>
<h3><span id="1annotationconfigapplicationcontext-调用注解-bean-定义读取器">1)AnnotationConfigApplicationContext 调用注解 Bean 定义读取器</span></h3><p>AnnotatedBeanDefinitionReader 的 register()方法向容器注册指定的注解 Bean，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册多个注解 Bean 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">        registerBean(annotatedClass);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册一个注解 Bean 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">	doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">	doRegisterBean(annotatedClass, instanceSupplier, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, String name, @Nullable Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">	doRegisterBean(annotatedClass, instanceSupplier, name, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bean 定义读取器注册注解 Bean 定义的入口方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">	doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bean 定义读取器向容器注册注解 Bean 定义类</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">	doRegisterBean(annotatedClass, <span class="keyword">null</span>, name, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bean 定义读取器向容器注册注解 Bean 定义类</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据指定的注解 Bean 定义类，创建 Spring 容器中对注解 Bean 的封装的数据结构</span></span><br><span class="line">	AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">	<span class="comment">//解析注解 Bean 定义的作用域</span></span><br><span class="line">	ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	<span class="comment">//为注解 Bean 定义设置作用域</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	<span class="comment">//为注解 Bean 定义生成 Bean 名称</span></span><br><span class="line">	String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">	<span class="comment">//处理注解 Bean 定义中的通用注解</span></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	<span class="comment">//如果在向容器注册注解 Bean 定义时，使用了额外的限定符注解，则解析限定符注解。</span></span><br><span class="line">	<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			<span class="comment">//如果配置了@Primary 注解，设置该 Bean 为 autowiring 自动依赖注入装配时的首选</span></span><br><span class="line">			<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果配置了@Lazy 注解，则设置该 Bean 为非延迟初始化，如果没有配置，则该 Bean 为预实例化</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果使用了除@Primary 和@Lazy 以外的其他注解，则为该 Bean 添加一个 autowiring 自动依赖注入装配限定符，该 Bean 在进 autowiring自动依赖注入装配时，根据名称装配限定符指定的 Bean</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">		customizer.customize(abd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个指定 Bean 名称的 Bean 定义对象，封装注解 Bean 定义类数据</span></span><br><span class="line">	BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	<span class="comment">//根据注解 Bean 定义类中配置的作用域，创建相应的代理对象</span></span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,<span class="keyword">this</span>.registry);</span><br><span class="line">	<span class="comment">//向 IOC 容器注册注解 Bean 类定义对象</span></span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码可以看出，注册注解 Bean 定义类的基本步骤：</p>
<p>a、需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。</p>
<p>b、使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定义类中通用的注解。<br>c、使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。<br>d、通过 BeanDefinitionReaderUtils 向容器注册 Bean。<br>下面继续分析这 4 步的具体实现过程</p>
<h3><span id="2annotationscopemetadataresolver-解析作用域元数据">2)AnnotationScopeMetadataResolver 解析作用域元数据</span></h3><p>AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作用域元信息，即判断注册的 Bean 是prototype还是singleton类型，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析注解 Bean 定义类中的作用域元信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">	ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">	<span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">		AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">		<span class="comment">//从注解 Bean 定义类的属性中查找属性为”Scope”的值，即@Scope 注解的值</span></span><br><span class="line">		AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">		<span class="comment">//将获取到的@Scope 注解的值设置到要返回的对象中</span></span><br><span class="line">		<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">			metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">			<span class="comment">//获取@Scope 注解中的 proxyMode 属性值，在创建代理对象时会用到</span></span><br><span class="line">			ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">			<span class="comment">//如果@Scope 的 proxyMode 属性为 DEFAULT 或者 NO</span></span><br><span class="line">			<span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">				<span class="comment">//设置 proxyMode 为 NO</span></span><br><span class="line">				proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//为返回的元数据设置 proxyMode</span></span><br><span class="line">			metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回解析的作用域元信息对象</span></span><br><span class="line">	<span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3annotationconfigutils-处理注解-bean-定义类中的通用注解">3)AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解</span></h3><p>AnnotationConfigUtils 类的 processCommonDefinitionAnnotations()在向容器注册 Bean 之前，首先对注解 Bean 定义类中的通用 Spring 注解进行处理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理 Bean 定义中通用注解</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">	AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">	<span class="comment">//如果 Bean 定义中有@Lazy 注解，则将该 Bean 预实例化属性设置为@lazy 注解的值</span></span><br><span class="line">	<span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">		lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">		<span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果 Bean 定义中有@Primary 注解，则为该 Bean 设置为 autowiring 自动依赖注入装配的首选对象</span></span><br><span class="line">	<span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">		abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果Bean定义中有@DependsOn注解，则为该Bean设置所依赖的Bean名称，将确保在实例化该 Bean 之前首先实例化所依赖的 Bean </span></span><br><span class="line">	AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">	<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setDependsOn(dependsOn.getStringArray(<span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (abd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span><br><span class="line">		AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">		<span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">			absBd.setRole(role.getNumber(<span class="string">"value"</span>).intValue());</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">		<span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">			absBd.setDescription(description.getString(<span class="string">"value"</span>));  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="4annotationconfigutils-根据注解-bean-定义类中配置的作用域为其应用相应的代理策略">4)AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略</span></h3><p>AnnotationConfigUtils 类的 applyScopedProxyMode()方法根据注解 Bean 定义类中配置的作用域@Scope 注解的值，为 Bean 定义应用相应的代理模式。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据作用域为 Bean 应用引用的代码模式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取注解 Bean 定义类中@Scope 注解的 proxyMode 属性值</span></span><br><span class="line">	ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">	<span class="comment">//如果配置的@Scope 注解的 proxyMode 属性值为 NO，则不应用代理模式</span></span><br><span class="line">	<span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">		<span class="keyword">return</span> definition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取配置的@Scope 注解的 proxyMode 属性值，如果为 TARGET_CLASS</span></span><br><span class="line">	<span class="comment">//则返回 true，如果为 INTERFACES，则返回 false</span></span><br><span class="line">	<span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">	<span class="comment">//为注册的 Bean 创建相应模式的代理对象</span></span><br><span class="line">	<span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="5beandefinitionreaderutils-向容器注册-bean">5)BeanDefinitionReaderUtils 向容器注册 Bean</span></h3><p>BeanDefinitionReaderUtils 校验 BeanDefinition 信息，然后将 Bean 添加到管理BeanDefinition 的 Map 中。</p>
<h2><span id="解析为beandefinition">解析为BeanDefinition</span></h2><p>当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的包及其子包，将扫描到的注解 Bean 定义载入并注册。</p>
<h3><span id="1classpathbeandefinitionscanner-扫描给定的包及其子包">1)ClassPathBeanDefinitionScanner 扫描给定的包及其子包</span></h3><p>AnnotationConfigApplicationContext通过调用类路径Bean定义扫描器ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类路径 Bean 定义扫描器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为容器创建一个类路径 Bean 定义扫描器，并指定是否使用默认的扫描过滤规则。	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,Environment environment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(registry, useDefaultFilters, environment,(registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="keyword">null</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="comment">//为容器设置加载 Bean 定义的注册器</span></span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line">		setEnvironment(environment);</span><br><span class="line">		<span class="comment">//为容器设置资源加载器</span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用类路径 Bean 定义扫描器入口方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取容器中已经注册的 Bean 个数</span></span><br><span class="line">		<span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//启动扫描器扫描给定包</span></span><br><span class="line">		doScan(basePackages);</span><br><span class="line">		<span class="comment">//注册注解配置(Annotation config)处理器</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">			AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回注册的 Bean 个数</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//类路径 Bean 定义扫描器扫描给定包及其子包</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">		<span class="comment">//创建一个集合，存放扫描到 Bean 定义的封装类</span></span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">		<span class="comment">//遍历扫描所有给定的包</span></span><br><span class="line">		<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">			<span class="comment">//调用父类的方法描给定类路径，获取符合条件的 Bean 定义</span></span><br><span class="line">			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">			<span class="comment">//遍历扫描到的 Bean</span></span><br><span class="line">			<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">				<span class="comment">//获取 Bean 定义类中@Scope 注解的值，即获取 Bean 的作用域</span></span><br><span class="line">				ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">				<span class="comment">//为 Bean 设置注解配置的作用域</span></span><br><span class="line">				candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">				<span class="comment">//为 Bean 生成名称</span></span><br><span class="line">				String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">				<span class="comment">//如果扫描到的 Bean 不是 Spring 的注解 Bean，则为 Bean 设置默认值，</span></span><br><span class="line">				<span class="comment">//设置 Bean 的自动依赖注入装配属性等</span></span><br><span class="line">				<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果扫描到的 Bean 是 Spring 的注解 Bean，则处理其通用的 Spring 注解</span></span><br><span class="line">				<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">					<span class="comment">//处理注解 Bean 中通用的注解，在分析注解 Bean 定义类读取器时已经分析过</span></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//根据 Bean 名称检查指定的 Bean 是否需要在容器中注册，或者在容器中冲突</span></span><br><span class="line">				<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">					<span class="comment">//根据注解中配置的作用域，为 Bean 应用相应的代理模式</span></span><br><span class="line">					definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,</span><br><span class="line"><span class="keyword">this</span>.registry);</span><br><span class="line">					beanDefinitions.add(definitionHolder);</span><br><span class="line">					<span class="comment">//向容器注册扫描到的 Bean</span></span><br><span class="line">					registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类路径 Bean 定义扫描器 ClassPathBeanDefinitionScanner 主要通过 findCandidateComponents()方法调用其父类 ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下的类。</p>
<h3><span id="2classpathscanningcandidatecomponentprovider-扫描给定包及其子包的类">2)ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</span></h3><p>ClassPathScanningCandidateComponentProvider 类的 findCandidateComponents()方法具体实现扫描给定类路径包的功能，主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">	<span class="comment">//保存过滤规则要包含的注解，即@Component、@Repository、@Service等</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; includeFilters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">//保存过滤规则要排除的注解</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; excludeFilters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">//构造方法，该方法在子类 ClassPathBeanDefinitionScanner 的构造方法中被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(Boolean useDefaultFilters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(useDefaultFilters, <span class="keyword">new</span> StandardEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(Boolean useDefaultFilters, Environment environment)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果使用 Spring 默认的过滤规则，则向容器注册过滤规则</span></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line">		setEnvironment(environment);</span><br><span class="line">		setResourceLoader(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向容器注册过滤规则</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//向要包含的过滤规则中添加@Component注解类</span></span><br><span class="line">		<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">		<span class="comment">//获取当前类的类加载器</span></span><br><span class="line">		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//向要包含的过滤规则添加 JavaEE6 的@ManagedBean 注解</span></span><br><span class="line">			<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">			((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">			logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//向要包含的过滤规则添加@Named 注解</span></span><br><span class="line">			<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">			((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">			logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//扫描给定类路径的包</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">			<span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">addCandidateComponentsFromIndex</span><span class="params">(CandidateComponentsIndex index, String</span></span></span><br><span class="line"><span class="function"><span class="params">	basePackage)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建存储扫描到的类的集合</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Set&lt;String&gt; types = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (TypeFilter filter : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">				String stereotype = extractStereotype(filter);</span><br><span class="line">				<span class="keyword">if</span> (stereotype == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Failed to extract stereotype from "</span>+ filter);</span><br><span class="line">				&#125;</span><br><span class="line">				types.addAll(index.getCandidateTypes(basePackage, stereotype));</span><br><span class="line">			&#125;</span><br><span class="line">			Boolean traceEnabled = logger.isTraceEnabled();</span><br><span class="line">			Boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line">			<span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">				<span class="comment">//为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息</span></span><br><span class="line">				MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);</span><br><span class="line">				<span class="comment">//如果扫描到的类符合容器配置的过滤规则</span></span><br><span class="line">				<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">					<span class="comment">//通过汇编(ASM)读取资源字节码中的 Bean 定义元信息</span></span><br><span class="line">					AnnotatedGenericBeanDefinition sbd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(</span><br><span class="line">					metadataReader.getAnnotationMetadata());</span><br><span class="line">					<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">							logger.debug(<span class="string">"Using candidate component class from index: "</span> + type);</span><br><span class="line">						&#125;</span><br><span class="line">						candidates.add(sbd);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">							logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + type);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">						logger.trace(<span class="string">"Ignored because matching an exclude filter: "</span> + type);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> candidates;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断元信息读取器读取的类是否符合容器定义的注解过滤规则</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Boolean <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//如果读取的类的注解在排除注解过滤规则中，返回 false</span></span><br><span class="line">		<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果读取的类的注解在包含的注解的过滤规则中，则返回 ture</span></span><br><span class="line">		<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">				<span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果读取的类的注解既不在排除规则，也不在包含规则中，则返回 false</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="ioc-容器初始化小结">IOC 容器初始化小结</span></h1><p>现在通过上面的内容，总结一下 IOC 容器初始化的基本步骤：</p>
<p>1、初始化的入口在容器实现中的 refresh()调用来完成。</p>
<p>2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition();</p>
<p>​    其中大致过程为：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等方式来定为资源位置。</p>
<p>​    如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源，也就是说Bean定义文件时通过抽象成 Resource来被IOC容器处理的 ，容器通过BeanDefinitionReader 来完成定义信息的解析和Bean信息的 注册 , 往往使用的是XmlBeanDefinitionReader来解析Bean的xml定义文件；BeanDefinitionParserDelegate来完成实际处理过程，从而得到Bean的定义信息，这些信息使用BeanDefinition对象来表示。</p>
<p>​    容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个Map来保存得到的 BeanDefinition 的过程。这个Map是持有Bean信息的场所，之后对Bean的操作都是针对这个Map来实现的。</p>
<p>​    然后就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了。</p>
<p>以下是容器初始化全过程的时序图：    </p>
<p><img src="https://raw.githubusercontent.com/jinzzzzz/image/master/blog/spring/spring-ioc.jpg" alt></p>

            </div>
          

    
      <footer class="post-footer">
      <ul class="post-copyright">
        <li class="post-copyright-author">
            <span>本文作者：</span>Jin Jin
        </li>
        <li class="post-copyright-link">
          <span>本文链接：</span>
          <a href="https://jinzzzzz.github.io//spring/spring-ioc.html" title="Spring源码分析之IOC">https://jinzzzzz.github.io/spring/spring-ioc.html</a>
        </li>
        <li class="post-copyright-license">
          <span>版权： </span>
          本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
        </li>
      </ul>
		
		<div class="post-tags">
		  
			<a href="/tags/Spring/">Spring</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/spring/spring-mvc-demo.html">
        <span class="next-text nav-default">手写Spring(一) 实现简易版Spring MVC</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>
      
        





    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

    
    
    
    
    
    

    <div id="gitalk-container"></div>

    <script>
        var gitalk = new Gitalk({
            clientID: '217672eb040280538293',
            clientSecret: '5a950867142dbcfd9fdc3de4491455bd3651c1a8',
            repo: 'jinzzzzz.github.io',
            owner: 'jinzzzzz',
            admin: 'jinzzzzz',
            id: location.pathname,      // Ensure uniqueness and length less than 50
            distractionFreeMode: 'false'  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>


      
      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2018 -
    
    2019
    <span class="footer-author">Jin Jin.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  



    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

<!--prettify代码高亮脚本引入-->


  </body>
</html>
